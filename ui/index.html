<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Recorder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opus-recorder/8.0.5/recorder.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
        }
        button {
            font-size: 1rem;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            cursor: pointer;
        }
        #status, #timer, #latency {
            margin-top: 1rem;
            font-weight: bold;
        }
        #audioPlayback {
            margin-top: 1rem;
        }
        #logArea {
            width: 100%;
            height: 400px;
            margin-top: 1rem;
            padding: 0.5rem;
            border: 1px solid #ccc;
            overflow-y: auto;
            text-align: left;
            font-family: monospace;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AI Voice Recorder</h1>
        <div id="timer">00:00:000</div>
        <div id="latency">Response Latency: 0.00ms</div>
        <button id="recordButton">Start Recording</button>
        <div id="status">Ready</div>
        <div id="audioPlayback"></div>
        <div id="logArea"></div>
    </div>

    <script>
        const recordButton = document.getElementById('recordButton');
        const status = document.getElementById('status');
        const audioPlayback = document.getElementById('audioPlayback');
        const logArea = document.getElementById('logArea');
        const timerDisplay = document.getElementById('timer');
        const latencyDisplay = document.getElementById('latency');

        let recorder;
        let socket;
        let isTestMode = true; // Set to true for test mode
        let recordedChunks = [];
        let startTime;
        let timerInterval;
        let totalBytes = 0;
        let sessionId = null;
        let turnId = 1;
        let isRecording = false;
        let isPlaying = false;
        let playbackStartTime = 0;
        let currentPlaybackDuration = 0;
        let stopRecordingTimeout;
        let recordingEndTime;
        const recordingBufferTime = 100; // 100ms buffer at the end of recording

        const config = {
            encoderPath: 'https://cdnjs.cloudflare.com/ajax/libs/opus-recorder/8.0.5/encoderWorker.min.js',
            streamPages: true,
            encoderApplication: 2048,
            encoderFrameSize: 20,
            encoderSampleRate: 16000,
            numberOfChannels: 1,
        };

        function log(message) {
            const timestamp = new Date().toISOString();
            logArea.innerHTML = `${timestamp} - ${message}<br>` + logArea.innerHTML;
        }

        function updateTimer() {
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            const milliseconds = elapsed % 1000;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
        }

        function initializeRecorder() {
            if (!Recorder.isRecordingSupported()) {
                status.textContent = 'Recording is not supported in this browser.';
                return;
            }

            recorder = new Recorder(config);

            recorder.onstart = () => {
                isRecording = true;
                status.textContent = 'Recording...';
                recordButton.textContent = 'Stop Recording';
                recordedChunks = [];
                totalBytes = 0;
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 10);
                log(`Recording started (Turn ${turnId})`);

                if (isPlaying) {
                    stopPlayback();
                    log(`Playback interrupted at ${currentPlaybackDuration.toFixed(2)}s`);
                }
            };

            recorder.onstop = () => {
                isRecording = false;
                status.textContent = 'Processing...';
                recordButton.textContent = 'Start Recording';
                recordButton.disabled = true;
                clearInterval(timerInterval);
                
                recordingEndTime = Date.now();
                const duration = (recordingEndTime - startTime) / 1000; // in seconds
                const sizeKB = totalBytes / 1024;
                const bitrateKBps = sizeKB / duration;
                
                log(`Recording stopped (Turn ${turnId}). Duration: ${duration.toFixed(2)}s, Size: ${sizeKB.toFixed(2)}KB, Bitrate: ${bitrateKBps.toFixed(2)}KB/s`);

                sendAudioToServer(startTime, recordingEndTime);
                turnId += 2;
            };

            recorder.ondataavailable = (typedArray) => {
                totalBytes += typedArray.byteLength;
                recordedChunks.push(typedArray);
            };
        }

        function initializeWebSocket() {
            if (isTestMode) {
                sessionId = 'test-session-' + Date.now();
                status.textContent = 'Test mode active. WebSocket not initialized.';
                log(`Test mode active. Session ID: ${sessionId}`);
                return;
            }

            try {
                socket = new WebSocket('ws://your-websocket-server-url');

                socket.onopen = () => {
                    sessionId = 'session-' + Date.now();
                    status.textContent = 'WebSocket connected.';
                    log(`WebSocket connected. Session ID: ${sessionId}`);
                };

                socket.onclose = () => {
                    status.textContent = 'WebSocket disconnected.';
                    log('WebSocket disconnected');
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    status.textContent = 'WebSocket error occurred. Switching to test mode.';
                    isTestMode = true;
                    log('WebSocket error occurred. Switched to test mode.');
                };

                socket.onmessage = (event) => {
                    handleServerResponse(JSON.parse(event.data));
                };
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                status.textContent = 'Failed to initialize WebSocket. Switching to test mode.';
                isTestMode = true;
                log('Failed to initialize WebSocket. Switched to test mode.');
            }
        }

        function sendAudioToServer(startTime, endTime) {
            const blob = new Blob(recordedChunks, { type: 'audio/ogg' });
            const metadata = {
                sessionId: sessionId,
                turnId: turnId,
                startTime: startTime,
                endTime: endTime
            };

            if (isTestMode) {
                // Simulate server processing and response
                setTimeout(() => {
                    const simulatedResponse = {
                        text: "This is a simulated response from the AI.",
                        audio: blob, // In real implementation, this would be the TTS audio
                        duration: blob.size / 16 // Estimate duration based on file size (assuming 16KB/s)
                    };
                    handleServerResponse(simulatedResponse);
                }, 1000); // Simulate 1-second processing time
            } else {
                // Here you would send the audio blob and metadata to the server via WebSocket
                // socket.send(JSON.stringify({ metadata: metadata, audio: blob }));
            }

            log(`Audio sent to server. Turn ID: ${turnId}, Start: ${startTime}, End: ${endTime}`);
        }

        function handleServerResponse(response) {
            const responseLatency = Date.now() - recordingEndTime;
            latencyDisplay.textContent = `Response Latency: ${responseLatency.toFixed(2)}ms`;
            log(`Received response from server. Latency: ${responseLatency.toFixed(2)}ms, Duration: ${response.duration}ms`);
            playServerResponse(response.audio, response.duration);
            recordButton.disabled = false;
            status.textContent = 'Ready';
        }

        function playServerResponse(audioBlob, duration) {
            const audio = new Audio(URL.createObjectURL(audioBlob));
            
            audio.onplay = () => {
                isPlaying = true;
                playbackStartTime = Date.now();
                log(`Started playing server response. Total latency: ${(playbackStartTime - recordingEndTime).toFixed(2)}ms`);
            };

            audio.onended = () => {
                isPlaying = false;
                currentPlaybackDuration = (Date.now() - playbackStartTime) / 1000;
                log(`Finished playing server response. Actual duration: ${currentPlaybackDuration.toFixed(2)}s`);
            };

            audio.play();
        }

        function stopPlayback() {
            if (isPlaying) {
                // In a real implementation, you would stop the audio playback here
                isPlaying = false;
                currentPlaybackDuration = (Date.now() - playbackStartTime) / 1000;
                log(`Playback stopped at ${currentPlaybackDuration.toFixed(2)}s`);
            }
        }

        recordButton.onclick = () => {
            if (isRecording) {
                clearTimeout(stopRecordingTimeout);
                stopRecordingTimeout = setTimeout(() => {
                    recorder.stop();
                }, recordingBufferTime);
            } else {
                recorder.start()
                    .then(() => console.log('Recording started'))
                    .catch((error) => {
                        console.error('Error starting recording:', error);
                        status.textContent = 'Error starting recording.';
                        log(`Error starting recording: ${error.message}`);
                    });
            }
        };

        // Initialize recorder and WebSocket when the page loads
        window.onload = () => {
            initializeRecorder();
            initializeWebSocket();
            log('Application initialized');
        };
    </script>
</body>
</html>
